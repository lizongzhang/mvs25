legend = TRUE)
partimat(Species ~ .,
data = iris,
method = "lda",
labels = c("S", "Ver", "Vir"))
partimat(Species ~ .,
data = iris,
method = "lda")
legend("topright", legend = levels(iris$Species),
col = c("darkgreen", "blue", "red"), pch = 19)
legend("topright", legend = levels(iris$Species),
col = c("darkgreen", "blue", "red"), pch = 10)
legend("topright", legend = levels(iris$Species),
col = c("darkgreen", "blue", "red"), pch = 10)
legend("topright", legend = levels(iris$Species),
col = c("darkgreen", "blue", "red"),
pch = 19)
# 自定义颜色：三类分别是绿色、蓝色、红色
class_colors <- c("darkgreen", "blue", "red")
# 绘制 QDA 判别边界 + 彩色样本点
partimat(Species ~ ., data = iris, method = "qda",
col.correct = class_colors,     # 正确分类点颜色
col.wrong = "black",            # 错误分类点颜色
imageplot = TRUE,               # 背景着色
main = "QDA Partition Plots with Color-Coded Classes")
# 添加图例（放在第一张图上合适的位置）
# 因为 par() 只影响最后一幅图，所以需要用 global coordinates
# 在分屏图中 legend 可能不显示，这里用 mfrow = c(2,3) 后直接单独加图例
par(fig = c(0, 0.5, 0.5, 1), new = TRUE)
plot.new()
legend("center", legend = levels(iris$Species),
col = class_colors, pch = 19, cex = 1.2, title = "Species")
legend("center", legend = levels(iris$Species),
col = class_colors, pch = 19, cex = 0.5, title = "Species")
# 自定义颜色：三类分别是绿色、蓝色、红色
class_colors <- c("darkgreen", "blue", "red")
# 绘制 QDA 判别边界 + 彩色样本点
partimat(Species ~ ., data = iris, method = "qda",
col.correct = class_colors,     # 正确分类点颜色
col.wrong = "black",            # 错误分类点颜色
imageplot = TRUE,               # 背景着色
main = "QDA Partition Plots with Color-Coded Classes")
# 添加图例（放在第一张图上合适的位置）
# 因为 par() 只影响最后一幅图，所以需要用 global coordinates
# 在分屏图中 legend 可能不显示，这里用 mfrow = c(2,3) 后直接单独加图例
par(fig = c(0, 0.5, 0.5, 1), new = TRUE)
plot.new()
legend("center", legend = levels(iris$Species),
col = class_colors, pch = 19, cex = 0.5, title = "Species")
library(klaR)
data(iris)
# 设置三类的颜色
cols <- c("darkgreen", "blue", "red")
# 画QDA判别图，正确分类用不同颜色显示
partimat(Species ~ ., data = iris, method = "qda",
col.correct = cols, col.wrong = "black",
main = "QDA Partition Plot (Iris)")
# 添加图例
legend("topright", legend = levels(iris$Species),
col = cols, pch = 19, cex = 0.8)
library(klaR)
data(iris)
# 设置三类的颜色
cols <- c("darkgreen", "blue", "red")
# 画QDA判别图，正确分类用不同颜色显示
partimat(Species ~ ., data = iris, method = "qda",
col.correct = cols, col.wrong = "black",
main = "QDA Partition Plot (Iris)")
# 添加图例
legend("topright", legend = levels(iris$Species),
col = cols, pch = 19, cex = 0.3)
# 设置三类的颜色
cols <- c("darkgreen", "blue", "red")
# 画QDA判别图，正确分类用不同颜色显示
partimat(Species ~ ., data = iris, method = "qda",
col.correct = cols, col.wrong = "black",
main = "QDA Partition Plot (Iris)")
# 添加图例
legend("topright", legend = levels(iris$Species),
col = cols, pch = 19, cex = 0.5)
partimat(Species ~ ., data = iris, method = "qda",
col.correct = "green3", col.wrong = "red")
partimat(Species ~ ., data = iris, method = "qda",
col.correct = "green3", col.wrong = "red")
iris %>%
group_by(Species) %>%
summarise(across(everything(), mean))
library(psych)
data(iris)
KMO(iris[,1:4])
KMO(iris)
KMO(wisc.data)
library(EFAtools)
install.packages("EFAtools")
data(wisc.data)
KMO(wisc.data)
# Bartlett 球形检验
cortest.bartlett(cor(iris_data), n = nrow(iris_data))
Bartlett(iris[,1:4])
BARTlett(iris[,1:4])
BARTLETT(iris[,1:4])
bartlett.test(iris[,1:4])
library(readr)
eg6_1 <- read_csv("eg6.1.csv")
eg6_1 <- eg6_1 %>% rename(数学 = x1,
物理 = x2,
化学 = x3,
语文 = x4,
历史 = x5,
英语 = x6)
library(tidyverse)
library(psych)
library(biotools)
library(MVN)
library(readr)
eg6_1 <- read_csv("eg6.1.csv")
eg6_1 <- eg6_1 %>% rename(数学 = x1,
物理 = x2,
化学 = x3,
语文 = x4,
历史 = x5,
英语 = x6)
library(psych)
KMO(eg6_1)
bartlett.test(eg6_1)
eg6_1.pr <- prcomp(eg6_1, scale = TRUE)
eg6_1.pr
summary(eg6_1.pr)
#方差贡献率的计算过程
eg6_1.summary <- summary(eg6_1.pr)
eg6_1.summary$sdev^2/sum(eg6_1.summary$sdev^2)
#  绘制碎石图、去掉网格线
library(factoextra)
library(ggplot2)
fviz_eig(eg6_1.pr) + theme_classic()
#纵轴代表特征值，也就是主成分的方差
fviz_eig(eg6_1.pr, choice = c("eigenvalue"))
#纵轴特征值，也就是方差贡献百分比
fviz_eig(eg6_1.pr, choice = c("variance"))
#只显示条形
fviz_eig(eg6_1.pr, choice = c("eigenvalue"),
geom = c("bar"))
#只画折线
fviz_eig(eg6_1.pr, choice = c("eigenvalue"),
geom = c("line"))
#标注方差贡献率
fviz_eig(eg6_1.pr,
addlabels = TRUE,
ylim = c(0, 70))
# 图形1 ：主成分与原始变量关系的可视化
#绘制变量相关圈variable correlation circle
#用于理解主成分与原始变量的关系、概括主成分的含义
#正相关的变量指向一个方向
#负相关的变量指向相反的方向
#原始变量的箭头长度(cos2)越长（越接近圆圈），代表该变量对主成分的贡献越大。
#原始变量的箭头长度越短（越接近圆心），代表该变量对主成分的贡献越小。
fviz_pca_var(eg6_1.pr)
fviz_pca_var(eg6_1.pr, repel = TRUE)
eg6_1.pr$rotation[,1:2]
fviz_pca_var(eg6_1.pr, repel = TRUE)
library(factoextra)
eg6_1.pr
fviz_pca_var(eg6_1.pr)
fviz_pca_var(eg6_1.pr, repel = TRUE) #避免标签重叠
eg6_1.pr$rotation[,1:2] #查看前两个主成分的载荷
str(eg6_1.pr)
# 相关图上的箭头上色，颜色由cos2映射
# cos2越高，代表主成分对该原始变量的代表性越好
fviz_pca_var(eg6_1.pr,
col.var = "cos2",
gradient.cols = c("#00AFBB", "#E7B800", "#FC4E07") ,
repel = TRUE # Avoid text overlapping
)
library(factoextra)
fviz_pca_ind(eg6_1.pr)
#不要遮挡标签
fviz_pca_ind(eg6_1.pr, repel = TRUE)
#给点加上颜色，第1主成分得分映射颜色
#查看第1主成分得分低或者得分高的个案，理解第一主成分的含义
fviz_pca_ind(eg6_1.pr,
repel = TRUE,
col.ind = eg6_1.pr$x[,1])
#给点加上颜色，第2主成分得分映射颜色
fviz_pca_ind(eg6_1.pr, repel = TRUE,
col.ind = eg6_1.pr$x[,2])
#在eg6_1中增加性别变量female
eg6_1$female <- as.factor(rbinom(52,1,0.5))
fviz_pca_ind(eg6_1.pr, repel = TRUE,
col.ind = eg6_1$female)
fviz_pca_ind(eg6_1.pr)
eg6_1.pr$x
library(readxl)
#读取数据文件
data <- read_xls("NFL.xlsx")
library(readxl)
data <- read_excel("NFL.xlsx")
#提取data中的第5至12列，保存为combine
combine <- data[, 5:12]
library(psych)
KMO(combine)
bartlett.test(combine)
#方法一：调用prcomp函数
combine.pr <- prcomp(combine, scale = TRUE)
combine.pr
#方法二：计算combine的相关系数矩阵的特征值和特征向量
combine %>% cor() %>% eigen()
combine.pr$sdev^2
#查看主成分的方差贡献率、累计方差贡献率
summary(combine.pr)
# 计算各个主成分的方差
pr.var <- combine.pr$sdev^2
pr.var
#  计算各个主成分的方差贡献率
pve <- pr.var/sum(pr.var)
pve
#绘制各个主成分的方差贡献率
plot(pve, xlab = "Principal Component",
ylab = "Proportion of Variance Explained",
ylim = c(0, 1), type = "b")
# 绘制累计方差贡献率
plot(cumsum(pve), xlab = "Principal Component",
ylab = "Cumulative Proportion of Variance Explained",
ylim = c(0, 1), type = "b")
#  绘制碎石图
library(factoextra)
fviz_eig(combine.pr)
# 绘制主成分1和主成分2的分组散点图
combine.pcscore <- cbind(data,combine.pr$x)
combine.pcscore %>% ggplot(aes(PC1,PC2, col= position))+
geom_point()
combine.pcscore %>% ggplot(aes(PC2,PC3, col= position))+
geom_point()
#Graph of individuals.
#Individuals with a similar profile are grouped together.
fviz_pca_ind(combine.pr,
col.ind = "cos2", # Color by the quality of representation
geom = c("point"),
gradient.cols = c("#00AFBB", "#E7B800", "#FC4E07"),
repel = TRUE     # Avoid text overlapping
)
# Graph of variables.
# Positive correlated variables point to the same side of the plot.
# Negative correlated variables point to opposite sides of the graph.
fviz_pca_var(combine.pr,
col.var = "contrib", # Color by contributions to the PC
gradient.cols = c("#00AFBB", "#E7B800", "#FC4E07"),
repel = TRUE     # Avoid text overlapping
)
#Biplot of individuals and variables
fviz_pca_biplot(combine.pr, repel = TRUE,
geom = c("point"),
col.var = "#2E9FDF", # Variables color
col.ind = "#696969"  # Individuals color
)
table(data$position)
#方法一：调用prcomp函数
combine.pr <- prcomp(combine, scale = TRUE)
combine.pr
#方法二：计算combine的相关系数矩阵的特征值和特征向量
combine %>% cor() %>% eigen()
combine.pr$sdev^2
#查看主成分的方差贡献率、累计方差贡献率
summary(combine.pr)
#查看主成分载荷
combine.pr$rotation[,1:2]
# 查看第2主成分载荷
combine.pr$rotation[,2]
table(data$position) %>%
arrange(desc(n))
table(data$position) %>%
as.data.frame() %>%
arrange(desc(n))
table(data$position) %>%
as.data.frame()
table(data$position) %>%
as.data.frame() %>%
arrange(desc(Freq))
combine.pcscore %>%
filter(position %in% c("RB","WR","TE")) %>%
ggplot(aes(PC1,PC2, col= position))+
geom_point()
combine.pcscore %>%
filter(position %in% c("RB","WR","TE")) %>%
ggplot(aes(PC1, col= position))+
geom_histogram()
combine.pcscore %>%
filter(position %in% c("RB","WR","TE")) %>%
ggplot(aes(PC1, col= position))+
geom_histogram() +
facet_wrap(~position)
combine.pcscore %>%
filter(position %in% c("RB","WR","TE")) %>%
ggplot(aes(PC1, col= position))+
geom_histogram() +
facet_wrap(~position, ncol = 1)
combine.pcscore %>%
filter(position %in% c("RB","WR","TE")) %>%
ggplot(aes(PC1, fill= position))+
geom_histogram() +
facet_wrap(~position, ncol = 1)
combine.pcscore %>%
filter(position %in% c("CB","DE","WR")) %>%
ggplot(aes(PC1, fill= position))+
geom_histogram() +
facet_wrap(~position, ncol = 1)
combine.pcscore %>%
filter(position %in% c("CB","DE","WR")) %>%
ggplot(aes(PC2, fill= position))+
geom_histogram() +
facet_wrap(~position, ncol = 1)
library(tidyverse)
library(factoextra)
library(psych)
library(readxl)
data <- read_excel("NFL.xlsx")
#提取data中的第5至12列，保存为combine
combine <- data[, 5:12]
library(psych)
KMO(combine)
bartlett.test(combine)
#方法一：调用prcomp函数
combine.pr <- prcomp(combine, scale = TRUE)
combine.pr
#方法二：计算combine的相关系数矩阵的特征值和特征向量
combine %>% cor() %>% eigen()
combine.pr$sdev^2
#查看主成分的方差贡献率、累计方差贡献率
summary(combine.pr)
#查看第1主成分载荷
combine.pr$rotation[,1:2]
# 计算各个主成分的方差
pr.var <- combine.pr$sdev^2
pr.var
#  计算各个主成分的方差贡献率
pve <- pr.var/sum(pr.var)
pve
#绘制各个主成分的方差贡献率
plot(pve, xlab = "Principal Component",
ylab = "Proportion of Variance Explained",
ylim = c(0, 1), type = "b")
# 绘制累计方差贡献率
plot(cumsum(pve), xlab = "Principal Component",
ylab = "Cumulative Proportion of Variance Explained",
ylim = c(0, 1), type = "b")
#  绘制碎石图
library(factoextra)
fviz_eig(combine.pr)
# 绘制主成分1和主成分2的分组散点图
combine.pcscore <- cbind(data,combine.pr$x)
combine.pcscore %>% ggplot(aes(PC1,PC2, col= position))+
geom_point()
combine.pcscore %>% ggplot(aes(PC2,PC3, col= position))+
geom_point()
#Graph of individuals.
#Individuals with a similar profile are grouped together.
fviz_pca_ind(combine.pr,
col.ind = "cos2", # Color by the quality of representation
geom = c("point"),
gradient.cols = c("#00AFBB", "#E7B800", "#FC4E07"),
repel = TRUE     # Avoid text overlapping
)
# Graph of variables.
# Positive correlated variables point to the same side of the plot.
# Negative correlated variables point to opposite sides of the graph.
fviz_pca_var(combine.pr,
col.var = "contrib", # Color by contributions to the PC
gradient.cols = c("#00AFBB", "#E7B800", "#FC4E07"),
repel = TRUE     # Avoid text overlapping
)
#Biplot of individuals and variables
fviz_pca_biplot(combine.pr, repel = TRUE,
geom = c("point"),
col.var = "#2E9FDF", # Variables color
col.ind = "#696969"  # Individuals color
)
table(data$position)
table(data$position) %>%
as.data.frame() %>%
arrange(desc(Freq))
combine.pcscore %>%
filter(position %in% c("CB","DE","WR")) %>%
ggplot(aes(PC1, fill= position))+
geom_histogram() +
facet_wrap(~position, ncol = 1)
# 绘制PC1主成分得分按位置分组的箱线图
combine.pcscore %>%
ggplot(aes(x = position, y = PC1, fill = position)) +
geom_boxplot() +
theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
labs(title = "不同位置球员PC1主成分得分分布", y = "PC1得分")
# 绘制PC2主成分得分按位置分组的箱线图
combine.pcscore %>%
ggplot(aes(x = position, y = PC2, fill = position)) +
geom_boxplot() +
theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
labs(title = "不同位置球员PC2主成分得分分布", y = "PC2得分")
# 绘制PC1主成分得分按位置分组的箱线图
combine.pcscore %>%
ggplot(aes(x = fct_reorder(position, PC1, .fun = median, .desc = TRUE),
y = PC1, fill = position)) +
geom_boxplot() +
theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
labs(title = "不同位置球员PC1主成分得分分布", x = "position", y = "PC1得分")
# 绘制PC2主成分得分按位置分组的箱线图
combine.pcscore %>%
ggplot(aes(x = position, y = PC2, fill = position)) +
geom_boxplot() +
theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
labs(title = "不同位置球员PC2主成分得分分布", y = "PC2得分")
# 绘制PC1主成分得分按位置分组的箱线图
combine.pcscore %>%
ggplot(aes(x = fct_reorder(position, PC1, .fun = median, .desc = TRUE),
y = PC1, fill = position)) +
geom_boxplot() +
theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
labs(title = "不同位置球员PC1主成分得分分布", x = "position", y = "PC1得分")
# 绘制PC2主成分得分按位置分组的箱线图
combine.pcscore %>%
ggplot(aes(x = fct_reorder(position, PC2, .fun = median, .desc = TRUE),
y = PC2, fill = position)) +
geom_boxplot() +
theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
labs(title = "不同位置球员PC2主成分得分分布", y = "PC2得分")
# 绘制PC1主成分得分按位置分组的箱线图
combine.pcscore %>%
ggplot(aes(x = fct_reorder(position, PC1, .fun = median, .desc = TRUE),
y = PC1, fill = position)) +
scale_fill_brewer(palette = "Set3") +
geom_boxplot() +
theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
labs(title = "不同位置球员PC1主成分得分分布", x = "position", y = "PC1得分")
# 绘制PC2主成分得分按位置分组的箱线图
combine.pcscore %>%
ggplot(aes(x = fct_reorder(position, PC2, .fun = median, .desc = TRUE),
y = PC2, fill = position)) +
geom_boxplot() +
theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
labs(title = "不同位置球员PC2主成分得分分布", y = "PC2得分")
# 绘制PC1主成分得分按位置分组的箱线图
combine.pcscore %>%
ggplot(aes(x = fct_reorder(position, PC1, .fun = median, .desc = TRUE),
y = PC1, fill = position)) +
scale_fill_brewer(palette = "Set3") +
geom_boxplot() +
theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
labs(title = "不同位置球员PC1主成分得分分布", x = "position", y = "PC1得分")
# 绘制PC2主成分得分按位置分组的箱线图
combine.pcscore %>%
ggplot(aes(x = fct_reorder(position, PC2, .fun = median, .desc = TRUE),
y = PC2, fill = position)) +
scale_fill_brewer(palette = "Set1") +
geom_boxplot() +
theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
labs(title = "不同位置球员PC2主成分得分分布", y = "PC2得分")
# 绘制PC1主成分得分按位置分组的箱线图
combine.pcscore %>%
ggplot(aes(x = fct_reorder(position, PC1, .fun = median, .desc = TRUE),
y = PC1, fill = position)) +
scale_fill_brewer(palette = "Set2") +
geom_boxplot() +
theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
labs(title = "不同位置球员PC1主成分得分分布", x = "position", y = "PC1得分")
# 绘制PC2主成分得分按位置分组的箱线图
combine.pcscore %>%
ggplot(aes(x = fct_reorder(position, PC2, .fun = median, .desc = TRUE),
y = PC2, fill = position)) +
scale_fill_brewer(palette = "Set1") +
geom_boxplot() +
theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
labs(title = "不同位置球员PC2主成分得分分布", y = "PC2得分")
# 绘制PC1主成分得分按位置分组的箱线图
combine.pcscore %>%
ggplot(aes(x = fct_reorder(position, PC1, .fun = median, .desc = TRUE),
y = PC1, fill = position)) +
scale_fill_brewer(palette = "Set3") +
geom_boxplot() +
theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
labs(title = "不同位置球员PC1主成分得分分布", x = "position", y = "PC1得分")
# 绘制PC2主成分得分按位置分组的箱线图
combine.pcscore %>%
ggplot(aes(x = fct_reorder(position, PC2, .fun = median, .desc = TRUE),
y = PC2, fill = position)) +
scale_fill_brewer(palette = "Pastel1") +
geom_boxplot() +
theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
labs(title = "不同位置球员PC2主成分得分分布", y = "PC2得分")
# 方差分析：不同位置的PC1得分是否有显著差异
anova_pc1 <- aov(PC1 ~ position, data = combine.pcscore)
summary(anova_pc1)
# 方差分析：不同位置的PC2得分是否有显著差异
anova_pc2 <- aov(PC2 ~ position, data = combine.pcscore)
summary(anova_pc2)
# k-means聚类（以2类为例）
set.seed(123)
km <- kmeans(combine.pcscore[, c("PC1", "PC2")], centers = 2)
combine.pcscore$cluster <- as.factor(km$cluster)
# 可视化聚类结果
ggplot(combine.pcscore, aes(PC1, PC2, color = cluster)) +
geom_point() +
labs(title = "基于主成分得分的球员聚类")
# k-means聚类（以2类为例）
set.seed(123)
km <- kmeans(combine.pcscore[, c("PC1", "PC2")], centers = 3)
combine.pcscore$cluster <- as.factor(km$cluster)
# 可视化聚类结果
ggplot(combine.pcscore, aes(PC1, PC2, color = cluster)) +
geom_point() +
labs(title = "基于主成分得分的球员聚类")
# 例：用PC1、PC2作为自变量预测某项能力
lm_result <- lm(forty ~ PC1 + PC2, data = combine.pcscore)
summary(lm_result)
prop.table(table(combine.pcscore$position, combine.pcscore$cluster), 1)
