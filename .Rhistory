#未旋转
fa.pc.none <- principal(eg7_1, nfactors = 2,
rotate = "none")
fa.pc.none
# com的含义
# com : Hoffman's index of complexity for each item，
#该值越接近于1，代表该原始变量主要由某个因子代表。
#未旋转
fa.pc.none <- principal(eg7_1, nfactors = 2,
rotate = "none")
fa.pc.none
fa.pc.none
# edit the file path accordingly
knitr::include_graphics("img/car_sales varible definition.png")
library(readxl)
attitude <- read_excel("attitude.xlsx")
attitude[, 2:31]
attitude[, 您人缘关系有多好分:子女有出息]
View(attitude)
attidude %>%
select(您人缘关系有多好分：子女有出息)
attidude %>%
dplyr::select(您人缘关系有多好分：子女有出息)
library(tidyverse)
attidude %>%
dplyr::select(您人缘关系有多好分：子女有出息)
attidude %>%
dplyr::select(您人缘关系有多好分：子女有出息)
attidude %>%
dplyr::select(您人缘关系有多好分:子女有出息)
attitude %>%
dplyr::select(您人缘关系有多好分:子女有出息)
fa_result <- fa(fa_df, nfactors = 3, rotate = "varimax")
library(psych)
fa_df <- attitude %>%
dplyr::select(您人缘关系有多好分:子女有出息)
library(psych)
fa_result <- fa(fa_df, nfactors = 3, rotate = "varimax")
print(fa_result)
fa_result <- principal(fa_df,
nfactors = 10,
rotate = "varimax")
fa_result
#按因子载荷系数降序排列
print(fa.pc.varimax$loadings,
digits = 3, cutoff = 0.5,sort = T)
#按因子载荷系数降序排列
print(fa_result$loadings,
digits = 3, cutoff = 0.5,sort = T)
fa_result$loadings
#按因子载荷系数降序排列
print(fa_result$loadings,
digits = 3, cutoff = 0.5,sort = T)
# 把载荷变为普通矩阵
L <- as.matrix(fa_result$loadings)   # rows = variables, cols = factors
# 计算每个变量在所有因子上的最大绝对载荷
max_abs_loading <- apply(abs(L), 1, max)
# 找出所有最大绝对载荷 < 0.5 的变量
threshold <- 0.5
remove_vars <- names(max_abs_loading)[max_abs_loading < threshold]
remove_vars
# 显示要移除的变量
if (length(remove_vars) == 0) {
cat("没有变量满足被移除条件 (max_abs_loading < ", threshold, ")\n", sep = "")
} else {
cat("将从数据中移除以下变量（max |loading| <", threshold, "）:\n")
print(remove_vars)
}
# 从 fa_df 中剔除这些变量，得到新的数据集
fa_df_trim <- fa_df[, !(names(fa_df) %in% remove_vars), drop = FALSE]
fa_df_trim
# 重新做主成分/因子分析（你可以根据需要调整 nfactors）
fa_result_trim <- principal(fa_df_trim,
nfactors = ncol(L),
rotate = "varimax",
scores = TRUE)
L
# 查看结果
print(fa_result_trim, cutoff = 0.3)
# 查看结果
print(fa_result_trim, cutoff = 0.3)
print(fa_result_trim$loadings,
digits = 3, cutoff = 0.5,sort = T)
# 重新做主成分/因子分析
fa_result_trim <- principal(fa_df_trim,
nfactors = 7,
rotate = "varimax",
scores = TRUE)
# 查看结果
print(fa_result_trim, cutoff = 0.3)
print(fa_result_trim$loadings,
digits = 3, cutoff = 0.5,sort = T)
# 把载荷变为普通矩阵
L <- as.matrix(fa_result_trim$loadings)   # rows = variables, cols = factors
# 计算每个变量在所有因子上的最大绝对载荷
max_abs_loading <- apply(abs(L), 1, max)
# 找出所有最大绝对载荷 < 0.5 的变量
threshold <- 0.5
remove_vars <- names(max_abs_loading)[max_abs_loading < threshold]
remove_vars
# 从 fa_df 中剔除这些变量，得到新的数据集
fa_df_trim2 <- fa_df_trim[, !(names(fa_df) %in% remove_vars), drop = FALSE]
# 第2轮调整：减少原始变量个数
# 把载荷变为普通矩阵
L <- as.matrix(fa_result_trim$loadings)   # rows = variables, cols = factors
# 计算每个变量在所有因子上的最大绝对载荷
max_abs_loading <- apply(abs(L), 1, max)
# 找出所有最大绝对载荷 < 0.5 的变量
threshold <- 0.5
remove_vars <- names(max_abs_loading)[max_abs_loading < threshold]
remove_vars
# 从 fa_df 中剔除这些变量，得到新的数据集
fa_df_trim2 <- fa_df_trim[, !(names(fa_df_trim) %in% remove_vars), drop = FALSE]
# 重新做主成分/因子分析
fa_result_trim2 <- principal(fa_df_trim2,
nfactors = 6,
rotate = "varimax",
scores = TRUE)
# 查看结果
print(fa_result_trim2$loadings,
digits = 3, cutoff = 0.5,sort = T)
# 重新做主成分/因子分析
fa_result_trim2 <- principal(fa_df_trim2,
nfactors = 7,
rotate = "varimax",
scores = TRUE)
# 查看结果
print(fa_result_trim2$loadings,
digits = 3, cutoff = 0.5,sort = T)
# 重新做主成分/因子分析
fa_result_trim2 <- principal(fa_df_trim2,
nfactors = 7,
rotate = "promax",
scores = TRUE)
# 查看结果
print(fa_result_trim2$loadings,
digits = 3, cutoff = 0.5,sort = T)
library(readxl)
attitude <- read_excel("attitude.xlsx")
library(tidyverse)
fa_df <- attitude %>%
dplyr::select(您人缘关系有多好分:子女有出息)
# 因子分析
fa_result <- principal(fa_df,
nfactors = 10,
rotate = "promax")
fa_result
#按因子载荷系数降序排列
print(fa_result$loadings,
digits = 3, cutoff = 0.5,sort = T)
# 第一轮调整：减少原始变量个数
# 把载荷变为普通矩阵
L <- as.matrix(fa_result$loadings)   # rows = variables, cols = factors
# 计算每个变量在所有因子上的最大绝对载荷
max_abs_loading <- apply(abs(L), 1, max)
# 找出所有最大绝对载荷 < 0.5 的变量
threshold <- 0.5
remove_vars <- names(max_abs_loading)[max_abs_loading < threshold]
remove_vars
# 从 fa_df 中剔除这些变量，得到新的数据集
fa_df_trim <- fa_df[, !(names(fa_df) %in% remove_vars), drop = FALSE]
# 重新做主成分/因子分析
fa_result_trim <- principal(fa_df_trim,
nfactors = 7,
rotate = "promax",
scores = TRUE)
# 查看结果
print(fa_result_trim, cutoff = 0.3)
print(fa_result_trim$loadings,
digits = 3, cutoff = 0.5,sort = T)
# 第2轮调整：减少原始变量个数
# 把载荷变为普通矩阵
L <- as.matrix(fa_result_trim$loadings)   # rows = variables, cols = factors
# 计算每个变量在所有因子上的最大绝对载荷
max_abs_loading <- apply(abs(L), 1, max)
# 找出所有最大绝对载荷 < 0.5 的变量
threshold <- 0.5
remove_vars <- names(max_abs_loading)[max_abs_loading < threshold]
remove_vars
# 从 fa_df 中剔除这些变量，得到新的数据集
fa_df_trim2 <- fa_df_trim[, !(names(fa_df_trim) %in% remove_vars), drop = FALSE]
# 重新做主成分/因子分析
fa_result_trim2 <- principal(fa_df_trim2,
nfactors = 7,
rotate = "promax",
scores = TRUE)
# 查看结果
print(fa_result_trim2$loadings,
digits = 3, cutoff = 0.5,sort = T)
#按因子载荷系数降序排列
print(fa_result$loadings,
digits = 3, cutoff = 0.5,sort = T)
# 查看结果
print(fa_result_trim2$loadings,
digits = 3, cutoff = 0.5,sort = T)
fa_result <- principal(fa_df,
nfactors = 10,
rotate = "promax")
fa_result
#按因子载荷系数降序排列
print(fa_result$loadings,
digits = 3, cutoff = 0.5,sort = T)
# 第一轮调整：减少原始变量个数
# 把载荷变为普通矩阵
L <- as.matrix(fa_result$loadings)   # rows = variables, cols = factors
# 计算每个变量在所有因子上的最大绝对载荷
max_abs_loading <- apply(abs(L), 1, max)
# 找出所有最大绝对载荷 < 0.5 的变量
threshold <- 0.5
remove_vars <- names(max_abs_loading)[max_abs_loading < threshold]
remove_vars
# 从 fa_df 中剔除这些变量，得到新的数据集
fa_df_trim <- fa_df[, !(names(fa_df) %in% remove_vars), drop = FALSE]
# 重新做主成分/因子分析
fa_result_trim <- principal(fa_df_trim,
nfactors = 7,
rotate = "promax",
scores = TRUE)
# 查看结果
print(fa_result_trim, cutoff = 0.3)
print(fa_result_trim$loadings,
digits = 3, cutoff = 0.5,sort = T)
# 把载荷变为普通矩阵
L <- as.matrix(fa_result_trim$loadings)   # rows = variables, cols = factors
# 计算每个变量在所有因子上的最大绝对载荷
max_abs_loading <- apply(abs(L), 1, max)
max_abs_loading
# 找出所有最大绝对载荷 < 0.5 的变量
threshold <- 0.5
remove_vars <- names(max_abs_loading)[max_abs_loading < threshold]
remove_vars
# 从 fa_df 中剔除这些变量，得到新的数据集
fa_df_trim2 <- fa_df_trim[, !(names(fa_df_trim) %in% remove_vars), drop = FALSE]
fa_df_trim2
# 重新做主成分/因子分析
fa_result_trim2 <- principal(fa_df_trim2,
nfactors = 6,
rotate = "promax",
scores = TRUE)
# 查看结果
print(fa_result_trim2$loadings,
digits = 3, cutoff = 0.5,sort = T)
# 绘制因子载荷系数图
fa.diagram(fa_result_trim2$loadings, digits = 3)
# 保存最终数据集
final_data <- cbind(attitude, fa_result_trim2$scores)
final_data
library(readxl)
attitude <- read_excel("attitude.xlsx")
library(tidyverse)
fa_df <- attitude %>%
dplyr::select(您人缘关系有多好分:子女有出息)
# 因子分析
fa_result <- principal(fa_df,
nfactors = 10,
rotate = "promax")
fa_result
#按因子载荷系数降序排列
print(fa_result$loadings,
digits = 3, cutoff = 0.5,sort = T)
# 第一轮调整：减少原始变量个数
# 把载荷变为普通矩阵
L <- as.matrix(fa_result$loadings)   # rows = variables, cols = factors
# 计算每个变量在所有因子上的最大绝对载荷
max_abs_loading <- apply(abs(L), 1, max)
# 找出所有最大绝对载荷 < 0.5 的变量
threshold <- 0.5
remove_vars <- names(max_abs_loading)[max_abs_loading < threshold]
remove_vars
# 从 fa_df 中剔除这些变量，得到新的数据集
fa_df_trim <- fa_df[, !(names(fa_df) %in% remove_vars), drop = FALSE]
# 重新做主成分/因子分析
fa_result_trim <- principal(fa_df_trim,
nfactors = 7,
rotate = "promax",
scores = TRUE)
# 查看结果
print(fa_result_trim, cutoff = 0.3)
print(fa_result_trim$loadings,
digits = 3, cutoff = 0.5,sort = T)
# 第2轮调整：减少原始变量个数
# 把载荷变为普通矩阵
L <- as.matrix(fa_result_trim$loadings)   # rows = variables, cols = factors
# 计算每个变量在所有因子上的最大绝对载荷
max_abs_loading <- apply(abs(L), 1, max)
# 找出所有最大绝对载荷 < 0.5 的变量
threshold <- 0.5
remove_vars <- names(max_abs_loading)[max_abs_loading < threshold]
remove_vars
# 从 fa_df 中剔除这些变量，得到新的数据集
fa_df_trim2 <- fa_df_trim[, !(names(fa_df_trim) %in% remove_vars), drop = FALSE]
# 重新做主成分/因子分析
fa_result_trim2 <- principal(fa_df_trim2,
nfactors = 6,
rotate = "promax",
scores = TRUE)
# 查看结果
print(fa_result_trim2$loadings,
digits = 3, cutoff = 0.5,sort = T)
# 绘制因子载荷系数图
fa.diagram(fa_result_trim2$loadings, digits = 3)
# 保存最终数据集
final_data <- cbind(attitude, fa_result_trim2$scores)
final_data %>%
select(性格:子女有出息, MR1:MR6) %>%
head()
final_data_long <- final_data %>%
pivot_longer(cols = starts_with("RC"),
names_to = "Factor",
values_to = "Score")
final_data_long %>%
ggplot(aes(x = Factor, y = Score, fill = as.factor(性别))) +
geom_boxplot() +
labs(title = "不同性别在各因子上的得分分布",
x = "因子",
y = "得分",
fill = "性别") +
theme_minimal()
final_data_long %>%
ggplot(aes(x = Factor, y = Score, fill = as.factor(male))) +
geom_boxplot() +
labs(title = "不同性别在各因子上的得分分布",
x = "因子",
y = "得分",
fill = "性别") +
theme_minimal()
# 分析男性和女性在因子1上的得分差异
final_data %>%
group_by(性别) %>%
summarise(across(starts_with("RC"), mean, na.rm = TRUE))
final_data %>%
group_by(性别) %>%
summarise(across(starts_with("RC"),
mean, na.rm = TRUE))
# 分析男性和女性在因子1上的得分差异
final_data %>%
group_by(male) %>%
summarise(across(starts_with("RC"),
mean, na.rm = TRUE))
# 分析男性和女性在因子1上的得分的分布的直方图
final_data %>%
ggplot(aes(RC1, fill = as.factor(male))) +
geom_histogram(col = 1, position = "identity", alpha = 0.5) +
labs(fill = "Gender") +
scale_fill_manual(values = c("blue", "pink")) +
theme_minimal() +
ggtitle("Distribution of RC1 by Gender")
# 分析男性和女性在因子1上的得分的分布的直方图
final_data %>%
ggplot(aes(RC1, fill = as.factor(male))) +
geom_histogram(col = 1, position = "identity", alpha = 0.5) +
labs(fill = "Male") +
scale_fill_manual(values = c("blue", "pink")) +
theme_minimal() +
ggtitle("Distribution of RC1 by Gender")
final_data %>%
ggplot(aes(RC1, fill = as.factor(EDU))) +
geom_histogram(col = 1, position = "identity", alpha = 0.5) +
labs(fill = "EDU") +
#scale_fill_manual(values = c("blue", "pink")) +
theme_minimal() +
ggtitle("Distribution of RC1 by Gender")
# K-means聚类分析
set.seed(123)  # For reproducibility
kmeans_result <- kmeans(final_data %>% select(starts_with("RC")), centers =
3, nstart = 25)
final_data$cluster <- as.factor(kmeans_result$cluster)
# 可视化聚类结果
final_data %>%
ggplot(aes(RC1, RC2, color = cluster)) +
geom_point() +
labs(title = "K-means Clustering of Attitude Data",
x = "RC1",
y = "RC2",
color = "Cluster") +
theme_minimal()
kmeans_result <- kmeans(final_data %>% select(starts_with("RC"),
age,
主要工作总收入),
centers =3,
nstart = 25)
kmeans_result <- kmeans(final_data %>% select(starts_with("RC"),
年龄,
主要工作总收入),
centers =3,
nstart = 25)
final_data$cluster <- as.factor(kmeans_result$cluster)
# 可视化聚类结果
final_data %>%
ggplot(aes(RC1, RC2, color = cluster)) +
geom_point() +
labs(title = "K-means Clustering of Attitude Data",
x = "RC1",
y = "RC2",
color = "Cluster") +
theme_minimal()
final_data %>% select(starts_with("RC"),
年龄,
主要工作总收入)
# 查看各聚类中心
kmeans_result$centers
# 可视化聚类结果
final_data %>%
ggplot(aes(年龄, 主要工作总收入, color = cluster)) +
geom_point() +
labs(title = "K-means Clustering of Attitude Data",
x = "RC1",
y = "RC2",
color = "Cluster") +
theme_minimal()
eq1 <- lm(主要工作总收入 ~ RC1 + RC2 + RC3 + RC4 + RC5 + RC6 + 年龄,
data = final_data)
summary(eq1)
eq1 <- lm(主要工作总收入 ~ RC1 + RC2 + RC3  + 年龄,
data = final_data)
summary(eq1)
#绘制因子载荷系数图
fa.diagram(fa.pc.none$loadings, digits = 3)
#绘制因子载荷系数图
fa.diagram(fa.pc.none$loadings, digits = 3)
# 读取数据
#P146，例题7.1 52名学生的6科目成绩
library(readr)
library(tidyverse)
eg7_1 <- read_csv("eg6.1.csv")
eg7_1 <- eg7_1 %>% rename(数学 = x1,
物理 = x2,
化学 = x3,
语文 = x4,
历史 = x5,
英语 = x6)
#计算KMO值，大于0.8适合，小于0.5不适合，适合降维。
library(psych)
KMO(eg7_1)
#BARTLETT检验，p值小于0.05，拒绝“原始变量的相关系数矩阵是单位阵（相互独立）”的原假设，适合降维。
library(EFAtools)
BARTLETT(eg7_1)
#计算特征值和特征向量
eg7_1.ev <- eg7_1 %>% cor() %>%
eigen()
eg7_1.ev
#绘制碎石图
#install.packages("nFactors")
library(nFactors)
eg7_1.ev$values %>% nScree() %>%
plotnScree(legend = F)
library(psych)
#未旋转
fa.pc.none <- principal(eg7_1, nfactors = 2,
rotate = "none")
fa.pc.none
# com的含义
# com : Hoffman's index of complexity for each item，
#该值越接近于1，代表该原始变量主要由某个因子代表。
#绘制因子载荷系数图
fa.diagram(fa.pc.none$loadings, digits = 3)
library(psych)
fa_result <- principal(fa_df,
nfactors = 10,
rotate = "promax")
fa_result
knitr::include_graphics("/img/chap8pic1.png")
#绘制cos2 plot
row$cos2
mosaicplot(caith,
color = TRUE,
cex.axis = 0.8,
border = 5,
main = "Eye Color and Hair Color")
#导入数据，修改行名，列名
library(MASS)
data(caith)
rownames(caith) <- c("eye.blue", "eye.light", "eye.medium", "eye.dark")
colnames(caith) <- c("hair.fair", "hair.red", "hair.medium",
"hair.dark", "hair.black")
chisq.test(caith)
mosaicplot(caith,
color = TRUE,
cex.axis = 0.8,
border = 5,
main = "Eye Color and Hair Color")
mosaicplot(caith,
color = RColorBrewer::brewer.pal(4, "Set2"),
cex.axis = 1,
main = "Eye Color and Hair Color",
las = 1)
mosaicplot(caith,
color = TRUE,
cex.axis = 0.8,
border = 5,
las = 1,
main = "Eye Color and Hair Color")
?CA
??CA
?FactorMineR::CA
library(FactoMineR)
res.ca <- CA(caith, graph = FALSE)
res.ca %>% summary()
res.ca
#使用MASS包中的corresp()函数计算对应分析
res <- corresp(caith, nf = 2)
res
# 运行对应分析，保留前 2 轴
res <- corresp(caith, nf = 2)
res
# 检查结果对象有哪些内容
str(res)
names(res)
library(FactoMineR)
res.ca <- CA(caith, graph = FALSE)
res.ca %>% summary()
res.ca
